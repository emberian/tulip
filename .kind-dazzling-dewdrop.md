# Discord-Style Bot Interactions for Tulip

## Overview

Add Discord-like interactive bot components to this Zulip fork by extending the existing widget system. Zulip already has `SubMessage` model and widget infrastructure for polls/todos - we extend this for richer bot interactions.

**Key Constraint**: All bots are trusted (private server), so no sandboxing needed.

---

## Implementation Phases

### Phase 1: Bot Interaction Event Routing (Foundation)

**Problem**: Currently `submessage` events broadcast to clients but NOT to bots. When users interact with widgets, bots never know.

**Changes**:

1. **Extend `zerver/actions/submessage.py`** (~20 lines)
   - After `send_event_on_commit()`, check if original message sender is a bot
   - If bot type is OUTGOING_WEBHOOK or EMBEDDED_BOT, queue interaction event

2. **New file: `zerver/worker/bot_interactions.py`** (~80 lines)
   - Queue worker that receives interaction events
   - For outgoing webhooks: POST to bot's URL with interaction payload
   - For embedded bots: Call handler's `handle_interaction()` method

3. **Extend `zerver/lib/outgoing_webhook.py`** (~40 lines)
   - Add `InteractionOutgoingWebhookService` class
   - Payload format: `{type: "interaction", interaction_type, custom_id, user_id, message_id, data}`

4. **New endpoint: `zerver/views/bot_interactions.py`** (~30 lines)
   - `POST /json/bot_interactions` - Frontend posts interactions here
   - Validates, creates submessage, routes to bot

**Migration**: Add `interaction_url` field to `Service` model (optional separate URL for interactions).

---

### Phase 2: Rich Embeds

**Data structure**:
```json
{
  "widget_type": "rich_embed",
  "extra_data": {
    "title": "Weather Report",
    "description": "Current conditions...",
    "color": 5814783,
    "fields": [{"name": "Temp", "value": "72F", "inline": true}],
    "thumbnail": {"url": "..."},
    "footer": {"text": "Updated 5m ago"}
  }
}
```

**Files**:
- `zerver/lib/widget.py` - Add `rich_embed` to valid types
- `zerver/lib/validator.py` - Add `check_rich_embed()` validator
- `web/src/rich_embed_widget.ts` (new) - Render embed card
- `web/templates/widgets/rich_embed.hbs` (new) - Template
- `web/styles/widgets.css` - Embed styles

---

### Phase 3: Interactive Buttons

**Data structure**:
```json
{
  "widget_type": "interactive",
  "extra_data": {
    "content": "Approve this request?",
    "components": [{
      "type": "action_row",
      "components": [
        {"type": "button", "style": "success", "label": "Approve", "custom_id": "approve_123"},
        {"type": "button", "style": "danger", "label": "Reject", "custom_id": "reject_123"}
      ]
    }]
  }
}
```

**Files**:
- `zerver/lib/validator.py` - Add `check_interactive_components()` validator
- `web/src/interactive_widget.ts` (new) - Render buttons, handle clicks
- `web/templates/widgets/interactive.hbs` (new) - Button template
- `web/styles/widgets.css` - Button styles (primary/secondary/success/danger/link)

**Button click flow**:
1. User clicks button
2. Frontend POSTs to `/json/bot_interactions` with `{custom_id, message_id}`
3. Backend creates submessage, queues for bot
4. Bot receives interaction, can reply/update message

---

### Phase 4: Select Menus

Extend interactive widget to support:
```json
{
  "type": "select_menu",
  "custom_id": "color_select",
  "placeholder": "Choose a color",
  "options": [
    {"label": "Red", "value": "red", "description": "A warm color"},
    {"label": "Blue", "value": "blue"}
  ],
  "min_values": 1,
  "max_values": 3
}
```

**Files**: Same as Phase 3, extend `interactive_widget.ts` and template.

---

### Phase 5: Modals

**Flow**:
1. Button has `show_modal: true` or bot responds with modal payload
2. Frontend renders modal overlay
3. User fills form, submits
4. Frontend POSTs `{type: "modal_submit", custom_id, fields: {...}}`

**Data structure**:
```json
{
  "custom_id": "feedback_modal",
  "title": "Submit Feedback",
  "components": [{
    "type": "action_row",
    "components": [{
      "type": "text_input",
      "custom_id": "feedback_text",
      "label": "Your feedback",
      "style": "paragraph",
      "required": true
    }]
  }]
}
```

**Files**:
- `web/src/bot_modal.ts` (new) - Modal rendering using existing overlay system
- `web/templates/bot_modal.hbs` (new) - Modal template

---

### Phase 6: Bot-Defined Slash Commands

**Model** (new):
```python
class BotCommand(models.Model):
    bot_profile = models.ForeignKey(UserProfile, on_delete=CASCADE)
    realm = models.ForeignKey(Realm, on_delete=CASCADE)
    name = models.CharField(max_length=32)  # e.g., "weather"
    description = models.TextField(max_length=100)
    options_schema = models.JSONField(default=list)  # [{name, type, description, required, choices}]

    class Meta:
        unique_together = ("realm", "name")
```

**API**:
- `POST /api/v1/bot_commands` - Bot registers command
- `GET /api/v1/bot_commands` - List commands for realm
- `DELETE /api/v1/bot_commands/{id}` - Unregister

**Frontend**:
- `web/src/bot_command_store.ts` (new) - Cache of bot commands, updated via events
- `web/src/composebox_typeahead.ts` - Extend to include bot commands in slash typeahead
- `web/src/server_events_dispatch.js` - Handle `bot_commands` event type

**Execution flow**:
1. User types `/weather London` in compose box
2. Typeahead shows bot-registered `/weather` command
3. User sends message
4. Backend detects bot command, queues `bot_command` event for owning bot
5. Bot receives `{command: "weather", args: "London", user_id, message_id}`

---

### Phase 7: Freeform HTML/JS Widgets

**Data structure**:
```json
{
  "widget_type": "freeform",
  "extra_data": {
    "html": "<div class='game-board'>...</div>",
    "css": ".game-board { display: grid; }",
    "js": "ctx.on('click', '.cell', (e) => ctx.post_interaction({cell: e.target.dataset.cell}))"
  }
}
```

**Files**:
- `web/src/freeform_widget.ts` (new)
  - Inject HTML into widget container
  - Scope CSS to message ID to prevent leakage
  - Execute JS with context object: `{message_id, post_interaction(data), on(event, selector, handler)}`

**JS Context API**:
```javascript
// Available to bot JS
ctx.message_id        // Current message ID
ctx.post_interaction(data)  // Send interaction to bot
ctx.on(event, selector, fn) // Event delegation within widget
ctx.update_html(html)       // Replace widget HTML (for bot responses)
```

---

## Files to Modify/Create

### Backend (Python)

| File | Action | Description |
|------|--------|-------------|
| `zerver/actions/submessage.py` | Modify | Route interactions to bot workers |
| `zerver/worker/bot_interactions.py` | Create | Queue worker for bot interactions |
| `zerver/views/bot_interactions.py` | Create | `/json/bot_interactions` endpoint |
| `zerver/views/bot_commands.py` | Create | Slash command registration API |
| `zerver/lib/widget.py` | Modify | Add new widget types |
| `zerver/lib/validator.py` | Modify | Add validators for new widget types |
| `zerver/lib/outgoing_webhook.py` | Modify | Add interaction payload format |
| `zerver/models/bots.py` | Modify | Add BotCommand model |

### Frontend (TypeScript)

| File | Action | Description |
|------|--------|-------------|
| `web/src/rich_embed_widget.ts` | Create | Rich embed rendering |
| `web/src/interactive_widget.ts` | Create | Buttons and select menus |
| `web/src/bot_modal.ts` | Create | Modal dialog system |
| `web/src/freeform_widget.ts` | Create | Freeform HTML/JS widgets |
| `web/src/bot_command_store.ts` | Create | Slash command cache |
| `web/src/widgets.ts` | Modify | Register new widget types |
| `web/src/composebox_typeahead.ts` | Modify | Include bot commands |
| `web/src/server_events_dispatch.js` | Modify | Handle new event types |

### Templates & Styles

| File | Action |
|------|--------|
| `web/templates/widgets/rich_embed.hbs` | Create |
| `web/templates/widgets/interactive.hbs` | Create |
| `web/templates/bot_modal.hbs` | Create |
| `web/styles/widgets.css` | Modify |

---

## Verification Plan

1. **Unit tests**: Add tests for each new validator and action function
2. **Integration test**: Create test bot that sends each widget type
3. **Manual testing**:
   - Send message with rich embed via API
   - Send message with buttons, click button, verify bot receives interaction
   - Register slash command, use in compose box
   - Send freeform widget, interact with it
4. **End-to-end**: Build simple game bot (e.g., tic-tac-toe) using freeform widgets

---

## Implementation Order

1. **Phase 1** (Foundation) - Must be first, all other phases depend on interaction routing
2. **Phase 2** (Rich Embeds) - Simplest widget type, good warmup
3. **Phase 3** (Buttons) - Core interactive primitive
4. **Phase 4** (Select Menus) - Extension of Phase 3
5. **Phase 6** (Slash Commands) - Can be parallel with 4/5
6. **Phase 5** (Modals) - Depends on button infrastructure
7. **Phase 7** (Freeform) - Most complex, do last
