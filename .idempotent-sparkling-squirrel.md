# Game Widget Abstractions for Tulip Bots

> **Status**: Brainstorming reference document
> **Created**: 2026-01-08
> **Purpose**: Ideation for future game-oriented bot capabilities

This document captures brainstorming on extending Tulip's bot widget system to support games (MUDs, board games, action games, etc.). It's a reference for future implementation, not an active implementation plan.

---

## Design Goals (from discussion)

- **Target games**: Board games, strategy, visual/arcade, puzzles (general toolkit)
- **Approach**: New declarative widget types (not just freeform library)
- **Sprite sources**: All options - emoji, image URLs, base64 embedded
- **Animation**: Nice to have (turn-based first, animations as enhancement)
- **Updates**: Support partial diffs, not just full state replacement
- **Per-user views**: Essential - different users can see different widget content

---

## Proposed Widget Types

### 1. Grid Widget

Declarative grid for board games, puzzles, roguelikes:

```json
{
  "widget_type": "grid",
  "extra_data": {
    "width": 8, "height": 8,
    "cell_size": 40,
    "cells": [
      {"x": 0, "y": 0, "content": "â™œ", "bg": "#ffffff", "fg": "#000"},
      {"x": 1, "y": 0, "content": "â™ž", "bg": "#cccccc"}
    ],
    "default_bg": "#eee",
    "on_cell_click": true,
    "show_coordinates": false
  }
}
```

**Games enabled**: Chess, checkers, tic-tac-toe, minesweeper, battleship, roguelikes, sudoku, crosswords

**Interactions**: `{type: "cell_click", x: 3, y: 4}`

---

### 2. Sprite Canvas Widget

Sprite-based 2D canvas with declarative placement:

```json
{
  "widget_type": "canvas",
  "extra_data": {
    "width": 400, "height": 300,
    "background": "#1a1a2e",
    "sprites": [
      {"id": "player", "emoji": "ðŸ§™", "x": 100, "y": 150, "scale": 2},
      {"id": "enemy", "image": "https://...", "x": 200, "y": 150},
      {"id": "coin", "base64": "data:image/png;...", "x": 50, "y": 50}
    ],
    "on_canvas_click": true,
    "on_sprite_click": true
  }
}
```

**Sprite sources** (all supported):
- `emoji`: Unicode emoji rendered as sprite
- `image`: URL to image
- `base64`: Embedded image data

**Games enabled**: Action games, visual puzzles, point-and-click adventures

**Interactions**: `{type: "canvas_click", x: 150, y: 200}` or `{type: "sprite_click", id: "enemy"}`

---

### 3. Card Widget

Specialized for card game UIs:

```json
{
  "widget_type": "cards",
  "extra_data": {
    "layout": "hand",  // or "pile", "grid", "fan"
    "cards": [
      {"id": "c1", "face": "ðŸ‚¡", "facedown": false, "selected": false},
      {"id": "c2", "face": "ðŸ‚¢", "facedown": true},
      {"id": "c3", "image": "https://...card-back.png", "facedown": true}
    ],
    "selectable": true,
    "max_select": 1,
    "on_card_click": true
  }
}
```

**Layouts**:
- `hand`: Fanned hand of cards (like holding cards)
- `pile`: Stacked pile (deck)
- `grid`: Arranged in grid (tableau)
- `fan`: Semi-circle fan

**Games enabled**: Poker, blackjack, solitaire, uno, trading card games

---

### 4. Timer Widget Enhancement

Add to any widget type:

```json
{
  "timer": {
    "seconds": 30,
    "on_expire": "timeout",
    "visible": true,
    "style": "bar"  // or "countdown", "hidden"
  }
}
```

**Use cases**: Timed turns, speed chess, quiz games

---

### 5. Keyboard Capture Enhancement

Add to any widget type:

```json
{
  "keyboard": {
    "enabled": true,
    "bindings": {
      "ArrowUp": "up",
      "ArrowDown": "down",
      "w": "up",
      "s": "down",
      "Space": "action",
      "Enter": "confirm"
    }
  }
}
```

**Interaction**: `{type: "keypress", action: "up"}`

**Use cases**: All action/arcade games, roguelike movement

---

### 6. Sound Effects Enhancement

Add to any widget type or update:

```json
{
  "sounds": {
    "hit": "data:audio/mp3;base64,...",
    "win": "/static/sounds/victory.mp3"
  },
  "play": "hit"  // Play immediately when widget renders/updates
}
```

Or trigger in updates:

```json
{
  "update": {
    "set_cells": [...],
    "play_sound": "hit"
  }
}
```

**Use cases**: Game feedback, victory/defeat audio, UI confirmation

---

### 7. Composite Widgets

Combine multiple widget types in a single message:

```json
{
  "widget_type": "composite",
  "extra_data": {
    "layout": "vertical",  // or "horizontal", "overlay"
    "widgets": [
      {
        "type": "grid",
        "width": 8, "height": 8,
        "cells": [...]
      },
      {
        "type": "hud",
        "bars": [{"label": "HP", "current": 75, "max": 100}],
        "stats": [{"label": "Score", "value": 1500}]
      },
      {
        "type": "interactive",
        "components": [...]
      }
    ]
  }
}
```

**Layouts**:
- `vertical`: Stack widgets top-to-bottom
- `horizontal`: Arrange side-by-side
- `overlay`: Layer widgets (for HUDs over game board)

**Use cases**: RPG screen (game board + stats + inventory), complex game UIs

---

### 8. HUD/Stats Sub-Widget

For use in composite widgets:

```json
{
  "type": "hud",
  "bars": [
    {"label": "HP", "current": 45, "max": 100, "color": "#ff4444"},
    {"label": "MP", "current": 80, "max": 80, "color": "#4444ff"}
  ],
  "stats": [
    {"label": "Score", "value": 1500},
    {"label": "Level", "value": 3}
  ]
}
```

---

## Critical Architecture: Per-User Views

For games with hidden information (poker hands, battleship boards), different users need to see different content.

### Two Syntaxes Supported

#### 1. Ownership Shorthand (Simple Cases)

For common "owner sees, others don't" patterns:

```json
{
  "widget_type": "cards",
  "extra_data": {
    "cards": [
      {"id": "c1", "face": "ðŸ‚¡", "owner": "user_123", "hidden_for_others": true},
      {"id": "c2", "face": "ðŸ‚®", "owner": "user_123", "hidden_for_others": true},
      {"id": "c3", "face": "ðŸ‚£", "owner": "user_456", "hidden_for_others": true}
    ]
  }
}
```

- `owner`: User ID who "owns" this element
- `hidden_for_others`: If true, non-owners see `facedown: true` or redacted content
- Server resolves at send time based on recipient

#### 2. Explicit Views (Complex Cases)

For full control over what each user sees:

```json
{
  "widget_type": "grid",
  "extra_data": {
    "views": {
      "user_123": {
        "cells": [
          {"x": 0, "y": 0, "content": "ðŸš¢", "bg": "#00f"},
          {"x": 1, "y": 0, "content": "ðŸ’¥", "bg": "#f00"}
        ]
      },
      "user_456": {
        "cells": [
          {"x": 0, "y": 0, "content": "?", "bg": "#888"},
          {"x": 1, "y": 0, "content": "ðŸ’¥", "bg": "#f00"}
        ]
      },
      "default": {
        "cells": [
          {"x": 0, "y": 0, "content": "?", "bg": "#888"},
          {"x": 1, "y": 0, "content": "?", "bg": "#888"}
        ]
      }
    }
  }
}
```

- `views`: Object keyed by user_id with complete widget data for each
- `default`: Used for spectators or users not explicitly listed
- Allows completely different content per viewer (not just hidden/visible)

**How it works**:
1. Bot sends widget with ownership markers or explicit views
2. Server stores complete widget data in SubMessage
3. When broadcasting event, server resolves per-recipient view
4. Each client receives only their resolved view

**Backend changes needed**:
- `send_event_on_commit()` must resolve per-user views before sending
- New helper: `resolve_widget_for_user(widget_data, user_id)`
- SubMessage stores full widget; events are user-filtered

---

## Critical Architecture: Partial Updates (Diffs)

Instead of sending complete widget state each time, bots can send diffs:

### Widget Update Message Format

```json
{
  "type": "widget_update",
  "message_id": 12345,
  "update": {
    "set_cells": [
      {"x": 3, "y": 4, "content": "X", "bg": "#ff0000"}
    ],
    "remove_sprites": ["enemy_1"],
    "add_sprites": [
      {"id": "explosion", "emoji": "ðŸ’¥", "x": 200, "y": 150}
    ],
    "set_timer": {"seconds": 15}
  }
}
```

**Diff operations by widget type**:

| Widget | Diff Operations |
|--------|----------------|
| Grid | `set_cells`, `clear_cells`, `set_default_bg` |
| Canvas | `add_sprites`, `remove_sprites`, `move_sprite`, `update_sprite` |
| Cards | `add_cards`, `remove_cards`, `update_card`, `reorder` |

**Backend**:
- New endpoint `PATCH /json/messages/{id}/widget`
- Merges diff with existing widget state
- Broadcasts merged state (or just diff?) to clients

**Frontend**:
- Widget renderers handle incremental updates
- Animate transitions between states

---

## Animation System

Add optional animations to updates:

```json
{
  "update": {
    "move_sprite": {
      "id": "player",
      "x": 200, "y": 150,
      "animate": {"duration": 300, "easing": "ease-out"}
    },
    "remove_sprites": {
      "ids": ["enemy_1"],
      "animate": {"effect": "fade", "duration": 200}
    }
  }
}
```

**Animation types**:
- Movement: `duration`, `easing`
- Appear/disappear: `fade`, `scale`, `instant`
- Emphasis: `shake`, `pulse`, `glow`

---

## Implementation Phases

### Phase 1: Grid Widget + Per-User Views (Foundation)
- Grid widget with cell click handling
- Per-user view resolution (both syntaxes)
- **Enables**: Chess, checkers, battleship, tic-tac-toe, minesweeper

### Phase 2: Partial Updates + HUD
- Diff/patch endpoint for efficient updates
- Client-side diff merging with animations
- HUD sub-widget for stats/bars
- **Enables**: Real-time game updates, score tracking

### Phase 3: Canvas Widget
- Sprite canvas with all source types (emoji, URL, base64)
- Sprite click detection
- **Enables**: Visual/action games, point-and-click

### Phase 4: Cards Widget
- Card layouts (hand, pile, grid, fan)
- Per-user card visibility (ownership shorthand)
- **Enables**: Poker, blackjack, solitaire, trading card games

### Phase 5: Composite Widgets
- Multiple widgets in single message
- Layout modes (vertical, horizontal, overlay)
- **Enables**: Full game screens (board + stats + controls)

### Phase 6: Enhancements
- Keyboard capture
- Timers with expiry events
- Sound effects
- Basic animations (fade, move, shake)

---

## Files to Create/Modify

### Backend
| File | Action | Purpose |
|------|--------|---------|
| `zerver/lib/validator.py` | Modify | Add grid/canvas/cards/composite validators |
| `zerver/lib/widget_views.py` | Create | Per-user view resolution |
| `zerver/lib/widget_updates.py` | Create | Diff merging logic |
| `zerver/views/messages.py` | Modify | Add widget PATCH endpoint |
| `zerver/lib/send_message.py` | Modify | Resolve views before broadcast |

### Frontend
| File | Action | Purpose |
|------|--------|---------|
| `web/src/grid_widget.ts` | Create | Grid renderer with cell clicks |
| `web/src/canvas_widget.ts` | Create | Sprite canvas renderer |
| `web/src/cards_widget.ts` | Create | Card hand/pile/grid layouts |
| `web/src/hud_widget.ts` | Create | HP bars, stats display |
| `web/src/composite_widget.ts` | Create | Widget composition/layout |
| `web/src/widget_keyboard.ts` | Create | Keyboard capture system |
| `web/src/widget_timer.ts` | Create | Timer display + expiry |
| `web/src/widget_audio.ts` | Create | Sound effect playback |
| `web/src/widget_animations.ts` | Create | Shared animation utilities |
| `web/src/widgets.ts` | Modify | Register new widget types |
| `web/src/widget_schema.ts` | Modify | Zod schemas for new widgets |

### Styles
| File | Action | Purpose |
|------|--------|---------|
| `web/styles/widgets.css` | Modify | Grid, canvas, cards, HUD styles |

---

## Verification Plan

1. **Unit tests**
   - Validators for each widget type
   - Per-user view resolution logic
   - Diff merge operations

2. **Integration tests**
   - Send grid widget, click cell, verify bot receives interaction
   - Send widget with per-user views, verify users see different content
   - Send widget update diff, verify merge and correct broadcast
   - Composite widget renders all sub-widgets

3. **Demo bots**
   - **Tic-tac-toe**: Grid widget, turn-based, simple
   - **Battleship**: Grid + per-user views (hidden boards)
   - **Blackjack**: Cards widget + per-user hands
   - **Clicker**: Canvas with sprites, sound effects
   - **RPG combat**: Composite (canvas + HUD + buttons)

---

## Additional Brainstorming

### More Widget Types to Consider

#### Inventory Widget
Grid-based item management with drag-drop:

```json
{
  "widget_type": "inventory",
  "extra_data": {
    "rows": 4, "cols": 5,
    "items": [
      {"slot": 0, "icon": "âš”ï¸", "name": "Iron Sword", "count": 1, "rarity": "common"},
      {"slot": 3, "icon": "ðŸ§ª", "name": "Health Potion", "count": 5, "rarity": "uncommon"}
    ],
    "on_item_click": true,
    "on_item_drag": true,  // For drag-drop
    "show_tooltips": true
  }
}
```

**Use cases**: RPGs, survival games, trading systems

---

#### Map/World Widget
Large scrollable/pannable maps with POIs:

```json
{
  "widget_type": "map",
  "extra_data": {
    "width": 100, "height": 100,  // World size
    "viewport": {"width": 20, "height": 15},  // Visible area
    "center": {"x": 50, "y": 50},  // Current view center
    "tiles": [
      {"x": 0, "y": 0, "terrain": "grass"},
      {"x": 1, "y": 0, "terrain": "water"}
    ],
    "markers": [
      {"id": "town", "x": 50, "y": 50, "icon": "ðŸ°", "label": "Capital"},
      {"id": "player", "x": 52, "y": 48, "icon": "ðŸ§™", "label": "You"}
    ],
    "fog_of_war": true,  // Unexplored areas hidden
    "on_tile_click": true,
    "on_marker_click": true,
    "scrollable": true
  }
}
```

**Use cases**: Strategy games, world exploration, roguelikes with large maps

---

#### Dialog Widget
NPC conversations with choices:

```json
{
  "widget_type": "dialog",
  "extra_data": {
    "speaker": {
      "name": "Old Wizard",
      "portrait": "ðŸ§™â€â™‚ï¸",  // or image URL
      "mood": "mysterious"
    },
    "text": "Ah, a brave adventurer! Tell me, what brings you to these ancient halls?",
    "choices": [
      {"id": "quest", "text": "I seek the legendary artifact."},
      {"id": "trade", "text": "I'm looking to trade."},
      {"id": "leave", "text": "I should be going."}
    ],
    "typing_effect": true  // Text appears letter by letter
  }
}
```

**Use cases**: RPGs, visual novels, interactive fiction

---

#### Leaderboard Widget
Ranked player/score lists:

```json
{
  "widget_type": "leaderboard",
  "extra_data": {
    "title": "High Scores",
    "entries": [
      {"rank": 1, "name": "Alice", "score": 15000, "highlight": false},
      {"rank": 2, "name": "Bob", "score": 12500, "highlight": true},  // Current player
      {"rank": 3, "name": "Charlie", "score": 10000, "highlight": false}
    ],
    "columns": ["rank", "name", "score"],
    "page": 1,
    "total_pages": 5,
    "on_page_change": true
  }
}
```

**Use cases**: Competitive games, achievements, rankings

---

#### Text/Terminal Widget
For MUD-style text displays:

```json
{
  "widget_type": "terminal",
  "extra_data": {
    "lines": [
      {"text": "You enter the dark cavern.", "color": "#aaa"},
      {"text": "A torch flickers on the wall.", "color": "#fa0", "bold": true},
      {"text": "", "color": null},  // Empty line
      {"text": "Exits: [N]orth, [E]ast", "color": "#0f0"}
    ],
    "max_lines": 20,  // Scroll buffer
    "input": {
      "enabled": true,
      "placeholder": "> ",
      "history": true  // Up/down for command history
    }
  }
}
```

**Interaction**: `{type: "terminal_input", text: "go north"}`

**Use cases**: MUDs, text adventures, CLI-style interfaces

---

### Multiplayer & Social Features

#### Game Sessions/Rooms

Games need a concept of "who's playing." Options:

**Option A: Topic-Based (Simple)**
- Each game is a Zulip topic
- Bot creates topic like "Battleship: Alice vs Bob"
- Players are determined by who's in the topic
- Works with existing infrastructure

**Option B: Explicit Player Lists**
- Widget includes `players` field
- Bot manages join/leave

```json
{
  "players": {
    "list": [
      {"id": "user_123", "name": "Alice", "role": "player", "ready": true},
      {"id": "user_456", "name": "Bob", "role": "player", "ready": false},
      {"id": "user_789", "name": "Charlie", "role": "spectator"}
    ],
    "min_players": 2,
    "max_players": 4,
    "allow_spectators": true
  }
}
```

**Recommendation**: Start with topic-based (simpler), add explicit player lists later if needed.

---

#### Turn Management

Bot controls turns, but widgets can display whose turn it is:

```json
{
  "turn": {
    "current_player": "user_123",
    "turn_number": 5,
    "time_remaining": 30,  // Combined with timer
    "order": ["user_123", "user_456", "user_789"]  // Turn order
  }
}
```

**Frontend**:
- Highlight current player
- Show "Your turn!" or "Waiting for Alice..."
- Disable interactions when not your turn (via `enabled_for` field?)

---

#### Interaction Permissions

Control who can interact with what:

```json
{
  "widget_type": "grid",
  "extra_data": {
    "cells": [...],
    "interaction_rules": {
      "default": "none",  // No one can interact by default
      "user_123": "all",  // This user can click any cell
      "user_456": "owned"  // This user can only click their own pieces
    }
  }
}
```

Or per-element:

```json
{
  "cells": [
    {"x": 0, "y": 0, "content": "â™œ", "clickable_by": ["user_123"]}
  ]
}
```

---

#### Spectator Experience

Spectators see `default` view (already handled by per-user views). Additional considerations:

- **Read-only mode**: Spectators can't interact
- **Delayed view**: Spectators see game with N second delay (anti-cheating)
- **Commentary**: Spectators can send messages but not game interactions

---

#### Lobby/Matchmaking Widget

Pre-game screen for setting up matches:

```json
{
  "widget_type": "lobby",
  "extra_data": {
    "game": "Battleship",
    "status": "waiting",  // waiting, starting, in_progress
    "host": "user_123",
    "players": [
      {"id": "user_123", "name": "Alice", "ready": true},
      {"id": "user_456", "name": "Bob", "ready": false}
    ],
    "settings": {
      "board_size": {"label": "Board Size", "value": "10x10", "options": ["8x8", "10x10", "12x12"]},
      "time_limit": {"label": "Turn Time", "value": "30s", "options": ["15s", "30s", "60s", "none"]}
    },
    "min_players": 2,
    "max_players": 2
  }
}
```

**Actions**:
- Join/Leave buttons
- Ready toggle
- Settings changes (host only)
- Start game button (host, when all ready)

---

### Bot Developer Experience (DX)

#### Python SDK for Game Bots

```python
from tulip_games import GameBot, Grid, Cards, Turn

class BattleshipBot(GameBot):
    def __init__(self):
        super().__init__()
        self.games = {}  # message_id -> game state

    def on_command(self, ctx, command, args):
        if command == "battleship":
            # Create new game
            game = BattleshipGame(ctx.players)
            widget = Grid(
                width=10, height=10,
                cells=game.get_cells_for(ctx.user_id),
                on_cell_click=True
            ).with_per_user_views(game.get_views())

            msg = ctx.send_widget(widget)
            self.games[msg.id] = game

    def on_interaction(self, ctx, interaction):
        game = self.games.get(ctx.message_id)
        if not game:
            return

        if interaction.type == "cell_click":
            result = game.fire(ctx.user_id, interaction.x, interaction.y)

            # Update widget with diff
            ctx.update_widget({
                "set_cells": [result.cell_update],
                "play_sound": "hit" if result.hit else "miss"
            })
```

**SDK provides**:
- `GameBot` base class with lifecycle hooks
- Widget builders (`Grid()`, `Canvas()`, `Cards()`)
- Interaction helpers
- Per-user view helpers
- State management utilities

---

#### Widget Builder Pattern (TypeScript)

For embedded bots or frontend-heavy implementations:

```typescript
import { Grid, Cards, Composite, Turn } from 'tulip-widgets';

const gameWidget = Composite.vertical([
  Grid.create(8, 8)
    .setCells(boardState.cells)
    .onCellClick()
    .withViews({
      [player1.id]: { cells: player1Board },
      [player2.id]: { cells: player2Board },
      default: { cells: spectatorBoard }
    }),

  HUD.create()
    .addBar('HP', player.hp, player.maxHp, 'red')
    .addStat('Score', player.score),

  Interactive.actionRow([
    Button.primary('Attack', 'attack'),
    Button.secondary('Defend', 'defend'),
    Button.danger('Flee', 'flee')
  ])
]).withTimer(30, 'timeout');

await ctx.sendWidget(gameWidget.toJSON());
```

---

#### Common Patterns Library

Pre-built patterns for common game mechanics:

```python
from tulip_games.patterns import TurnBased, GridBased, CardGame

class ChessBot(TurnBased, GridBased):
    BOARD_SIZE = 8

    def initial_board(self):
        return chess_starting_position()

    def valid_moves(self, player, piece, from_pos):
        # Return list of valid destination squares
        return chess_rules.get_moves(self.board, piece, from_pos)

    def on_move(self, player, from_pos, to_pos):
        # Handle piece movement
        self.board.move(from_pos, to_pos)
        self.next_turn()
```

---

#### Example Bot Templates

Ready-to-fork templates:

1. **Simple Grid Game** (Tic-tac-toe)
   - Basic 2-player turn-based
   - Grid widget
   - Win detection

2. **Hidden Info Game** (Battleship)
   - Per-user views
   - Setup phase + play phase
   - Complex state management

3. **Card Game** (Blackjack)
   - Cards widget
   - Dealer vs players
   - Betting mechanics

4. **Action Game** (Whack-a-Mole)
   - Canvas with sprites
   - Timers
   - Sound effects
   - Scoring

5. **RPG Combat** (Turn-based battle)
   - Composite widgets
   - Multiple phases (attack/defend/item)
   - HP/MP management

---

---

## Real-Time Architecture Deep Dive

### Current Event System

Zulip uses **HTTP long-polling**, not WebSockets:

```
Django â†’ RabbitMQ â†’ Tornado â†’ HTTP long-poll â†’ Client
```

**Key characteristics:**
- Push-based to Tornado (low latency when connected)
- Heartbeat every 45-55 seconds (keeps connection alive)
- Event delivery is milliseconds if client has open connection
- RabbitMQ handles load distribution across Tornado shards

**Current latency profile:**
| Scenario | Latency |
|----------|---------|
| Client connected | ~10-50ms |
| Client reconnecting | Up to 55 seconds |
| Bot processing | Adds 50-200ms (queue worker) |

### Game Speed Tiers

Different games have different latency requirements:

| Tier | Update Rate | Latency Budget | Examples |
|------|------------|----------------|----------|
| **Turn-based** | 0.1-1/sec | 500ms+ | Chess, battleship, card games |
| **Casual real-time** | 2-10/sec | 100-200ms | Whack-a-mole, typing games |
| **Action** | 10-30/sec | <50ms | Platformers, shooters |
| **Twitch** | 30-60/sec | <16ms | Fighting games, rhythm games |

**Current system handles**: Turn-based and slow casual real-time
**Needs enhancement for**: Fast casual and action games
**Probably out of scope**: Twitch-speed games (need dedicated game server)

### Architecture Options

#### Option A: Optimize Existing (Minimal Changes)

Keep HTTP long-polling but optimize:

1. **Reduce heartbeat interval** for game topics
   - 5-10 seconds instead of 45-55
   - Increases server load but improves reconnect time

2. **Bypass bot worker queue** for simple games
   - Direct response from Tornado instead of queueing
   - Bot registers "fast path" handlers

3. **Client-side prediction**
   - Client shows optimistic UI
   - Server confirms/corrects

**Pros**: Minimal architecture changes
**Cons**: Still limited to ~100ms latency, higher server load

---

#### Option B: WebSocket Channel for Games (Recommended)

Add WebSocket endpoint specifically for game interactions:

```
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Regular events:           â”‚                     â”‚
  Django â†’ RabbitMQ â†’ Tornado â†’ HTTP long-pollâ”€â”€â”¤
                                                â”‚  Client
Game events:                                    â”‚
  Bot â† WebSocket â† Tornado â† WebSocket â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                          â”‚                     â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**New endpoint**: `GET /ws/game/{message_id}`
- Opens WebSocket for specific game session
- Bot can send/receive directly without queue worker
- Tornado handles routing

**Implementation:**

1. **Tornado WebSocket Handler** (`zerver/tornado/game_websocket.py`):
```python
class GameWebSocketHandler(WebSocketHandler):
    def open(self, message_id):
        self.message_id = message_id
        self.user = self.get_current_user()
        register_game_client(message_id, self)

    def on_message(self, message):
        # Route to bot
        interaction = json.loads(message)
        route_game_interaction(self.message_id, self.user, interaction)

    def on_close(self):
        unregister_game_client(self.message_id, self)

# Bot can push updates:
def push_game_update(message_id, user_id, update):
    clients = get_game_clients(message_id, user_id)
    for client in clients:
        client.write_message(json.dumps(update))
```

2. **Frontend WebSocket client** (`web/src/game_socket.ts`):
```typescript
class GameSocket {
    private ws: WebSocket;
    private widget: GameWidget;

    connect(messageId: number) {
        this.ws = new WebSocket(`wss://${host}/ws/game/${messageId}`);
        this.ws.onmessage = (e) => this.handleUpdate(JSON.parse(e.data));
    }

    sendInteraction(data: GameInteraction) {
        this.ws.send(JSON.stringify(data));
    }

    handleUpdate(update: WidgetUpdate) {
        this.widget.applyDiff(update);
    }
}
```

3. **Widget opt-in**:
```json
{
  "widget_type": "canvas",
  "extra_data": {
    "realtime": true,  // Enable WebSocket mode
    "update_rate": 10  // Target updates per second
  }
}
```

**Pros**:
- True real-time (<50ms possible)
- Bi-directional communication
- Per-game connection (no global impact)

**Cons**:
- More complex architecture
- WebSocket connection management
- Different code path for real-time vs turn-based

---

#### Option C: Hybrid Approach

Use appropriate transport based on game type:

| Widget Config | Transport | Latency |
|---------------|-----------|---------|
| `realtime: false` (default) | HTTP long-poll | ~50-200ms |
| `realtime: true` | WebSocket | ~10-50ms |

**Auto-upgrade**: Widget starts with HTTP, upgrades to WebSocket if `realtime: true`

```typescript
// In widget initialization
if (widgetData.extra_data.realtime) {
    this.socket = new GameSocket(messageId);
    this.socket.connect();
} else {
    // Use normal event system
    this.useHttpEvents();
}
```

**Pros**: Best of both worlds, backwards compatible
**Cons**: Two code paths to maintain

---

### Recommendation

**Start with Option A** (optimize existing) for v1:
- Handles turn-based and casual real-time well
- No architecture changes needed
- Add client-side prediction for better UX

**Add Option B** (WebSocket) for v2 when needed:
- Only implement when action games are a priority
- Can be scoped to specific widget types (canvas with `realtime: true`)
- Keeps regular widgets on proven HTTP path

### Client-Side Prediction Pattern

Even with HTTP, prediction makes games feel responsive:

```typescript
// User clicks cell
function onCellClick(x: number, y: number) {
    // 1. Immediately show optimistic update
    this.grid.setCellPending(x, y, currentPlayer.symbol);

    // 2. Send to server
    this.postInteraction({ type: "cell_click", x, y });
}

// Server confirms/rejects
function onServerResponse(response: InteractionResponse) {
    if (response.success) {
        // 3a. Confirm pending state
        this.grid.confirmCell(response.x, response.y);
    } else {
        // 3b. Rollback
        this.grid.rollbackCell(response.x, response.y);
        this.showError(response.error);
    }
}
```

**Widget schema for prediction:**
```json
{
  "widget_type": "grid",
  "extra_data": {
    "prediction": {
      "enabled": true,
      "cell_click": {
        "action": "set_content",
        "value": "{current_player.symbol}",
        "style": "pending"  // Visual indicator
      }
    }
  }
}
```

---

### Questions for Further Discussion

1. **Game persistence**: Should games survive server restart? How long?

2. **Anti-cheat**: For competitive games, how much validation should server do?

3. **Mobile support**: Touch events for canvas? Responsive layouts?

4. **Accessibility**: Screen reader support for game widgets?
